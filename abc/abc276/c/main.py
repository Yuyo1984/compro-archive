# 解説AC
N = int(input())
P = list(map(int, input().split()))

# 出力例2を見てみると、末項の５項のみが変化している。
# また、入力の末項４項は単調増加であり、出力の末項４項は単調減少である。
# P≠(1,...,N)なので、Pn>Pn+1<Pn+2<...<PNとなるようなNが取れる。
# Pn+1,...,PNのみを並べ替えてPより辞書順で小さい順列を構成することはできないので、
# 「先頭に近い要素はなるべく変化させない」ということは、答えはPn,...,PNを入れ替えたものになる。
# さらに、第n項は必ず異なる値になる。（そうでなければ、Pn+1,...,PNのみを並び替えるのと同じになる。）

# 先頭n-1項は変化させず、第n項は変化させるので、Pより辞書順で小さくなることは、第n項がPnより小さくなることと同値。
# 答えは、Pより辞書順で小さい順列のうち最大のものなので、第n項をPn,...PNのうちPn未満で最大のものにしなければならない。
# そして、このもとで、第n+1以降はどのように並べても得られる順列は辞書順でPより小さくなる。
# よって、第n+1項以降を辞書順で最大にする、すなわち残った要素を降順に並べれば答えが得られる。

# 個人的まとめ
# 観察のところに関しては納得行った。言われれば確かに・・・
# n+1項から末項までをどう並び替えても、元の数列より辞書順で大きなものしかできない。
# だから、n項から末項を並び替えたものが答えだ。
# n項だけが元と違う値になるのは、もし同じなら元の数列と同じ位置に固定されるため、さっきのn+1項から末項までを並び替えるのと同じになってしまうから。
# 先頭のn-1項を固定させて、n項を変化させるから、Pより辞書順で小さくなることは、n項がPnより小さくなることと同じだ。
# (だって、そうしないと絶対辞書順で大きなものしかできなくなっちゃうからね)
# 答えは、Pより辞書順で小さい順列のうち最大のものなので、第n項にきて欲しいのは、n項から末項の中の要素でPn未満で最大のものだ。
# それを持ってきさえすれば、あとはどう並べても辞書順で元の順列より小さくなる。
# その中でn+1項以降を辞書順で最大にしたいなら、降順に並べればいい。
# それが答えになる

# 解説の実装例でうまくいく理由
# まず、後ろから大小関係を見て、直前の要素の方が大きくなってるインデックス(j)を取得
# 取得したインデックスの要素と末項からまた大小関係を見ていって、見てるインデックスの要素が大きくなってるインデックス(k)を取得
# 要素をスワップさせれば、n項目がPn未満で最大のものになる。また、その後のものは昇順になってるので、リバースさせて合体させれば答えが取得できる。
# n項目のnを取得するのが1個目の操作。Pn未満で最大の要素を探すのが2個目の操作。
# 元の順列でn+1項以降の大小関係は保たれているからこれで問題ない。

j = N - 2
while P[j] < P[j + 1]:
    j -= 1

k = N - 1
while P[j] < P[k]:
    k -= 1

P[j], P[k] = P[k], P[j]
ans = P[: j + 1] + P[:j:-1]
print(*ans)
